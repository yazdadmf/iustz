#include<iostream>
#include<string>
#include<vector>
#include<random>
#include<algorithm>
#include <utility>
#include<iomanip>
#include<windows.h>
#include "Item.h" 
#include "Armor.h"
#include "weapon.h"

#include "Meds.h"
#include "printstuff.h"
#include "character.h"
#include"nonfreindly.h"
#include"zombie.h"

//#include<>
//#include<>

using namespace std;

string input(vector<string> choices) {
    string ans;

    do {
        cout << "Enter your choice: ";
        cin >> ans;

        for (const string& choice : choices) {
            if (choice == ans) {
                return ans;
            }
        }

        cout << "Invalid input. Please try again." << endl;

    } while (true);
}





//The main class of weapons






// mehrab ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^







class Party{
    public:
    vector<Character> group;
    vector<Item*> inventory;
    Party(int god){
        group.push_back(Character(1));
        group.push_back(Character(2));
        inventory.push_back(new Meds("health1"));
        inventory.push_back(new Meds("health1"));
        inventory.push_back(new Meds("stamina1"));
        inventory.push_back(new Throwables("molotov"));
         inventory.push_back(new Throwables("granade"));
        
    }
    void addItemToInventory(Item* a){
        inventory.push_back(a);
         cout << "Added item to inventory: " << a->type << endl;
        delete a;
    }
    // Function to add items from loot to the party inventory
    void addLootToInventory(vector<Item*> loot) {
        for (Item* item : loot) {
          addItemToInventory(item);
        
      }
      
    }

    void displaystatus(){
        for(int i=0; i<group.size(); i++){
            group[i].displayStatus();
        }
    }
    bool lose(){
        bool ret=true;
        for(int i=0 ;i<group.size(); i++){
            if(group[i].Health<=0){
                cout<<group[i].name<<"died";

            }
            else{ret=false;}
        }   
        return ret;
    }
    
   Item* craft(Item* item1, Item* item2) { 
    // Check the type of one of the items (assuming both have the same type) 
    string itemType = item1->type; 
 
    // Combine IDs of item1 and item2 
    string combinedId = item1->id + item2->id; 
 
    // Vector to store the craftable IDs 
    vector<string> craftableIds;   
 
    // Check if the combined ID exists in the craftable IDs 
    auto it = find(craftableIds.begin(), craftableIds.end(), combinedId);   
    if (it != craftableIds.end()) {   
        // Remove item1 and item2 from inventory and memory   
        // Implement removal from inventory 
 
        // Create a new item with the combined ID and type 
        Item* craftedItem = nullptr; 
        if (itemType == "Weapon") { 
            Weapon* weapon = new Weapon(combinedId); 
            craftedItem = weapon; 
        } else if (itemType == "Armor") { 
            Armor* armor = new Armor(combinedId); 
            craftedItem = armor; 
        } else if (itemType == "Meds") { 
            Meds* meds = new Meds(combinedId); 
            craftedItem = meds; 
        } else if (itemType == "Throwables") { 
            Throwables* throwables = new Throwables(combinedId); 
            craftedItem = throwables; 
        } 
 
        // Add the crafted item to inventory 
        // Implement addition to inventory 
 
        cout << "Crafted item with ID: " << combinedId << " and type: " << itemType << endl;   
 
        // Return the crafted item   
        return craftedItem;   
    } else {   
        cout << "Crafting failed. No matching recipe found." << endl;   
        return nullptr;   
    }  }



    Item* chooseusableitem() {
    while (true) {
        cout << "-------------------------------------------------------" << endl;
        int row = 0;
        for (int i = 0; i < inventory.size(); i++) {
            if (inventory[i]->type == "Meds" || inventory[i]->type == "Throwables") {
                cout << i + 1 << ". " << setw(18) << left << inventory[i]->id;
                row++;
                if (row % 4 == 0) {
                    cout << endl;
                }
            }
        }
        cout << endl << "-------------------------------------------------------" << endl;

        int choice;
        cout << "Enter the number of the item you want to use (0 to cancel): ";
        cin >> choice;

        if (choice == 0) {
            cout << "Operation canceled." << endl;
            return nullptr; // Cancel operation
        }

        if (choice < 1 || choice > inventory.size()) {
            cout << "Invalid choice. Please try again." << endl;
            continue; // Restart the loop
        }

        // Adjust index to match vector indexing
        int index = choice - 1;

        cout << "You selected:" << endl;
        cout << "Item ID: " << inventory[index]->id << endl;
        cout << "Item Details: " << inventory[index]->detail << endl;

        // Confirm the selection
        char confirm;
        cout << "Are you sure you want to use this item? (Y/N): ";
        cin >> confirm;
        if (confirm == 'Y' || confirm == 'y') {
            auto selected = inventory[index];
            inventory.erase(inventory.begin() + index);
            return selected;
        } else {
            cout << "Operation canceled." << endl;
            return nullptr; // Cancel operation
        }
    }
}

	void applyEffects(){
		for(int i=0;i<group.size();i++){
			group[i].applyEffects();
		}
	}
};


void encounter(Party party,Zombie zombie) {

    while (true) {
        //int partAttack = generateRandomNumber();
        int defender = 4;
        party.displaystatus();
        zombie.displaystatus();

        for (size_t i = 0; i < party.group.size(); i++) {
            //naghes
            cout << "------------------------\n "
               << party.group[i].displayFightInfo() << "1, ↑ Attack"
                  << party.group[i].getStaminaCostAttack() << "  2,  Defend"
                << party.group[i].getStaminaCostDefend() << "  3. ȏ Use item\n"
                << "------------------------\n";
            int bezar=stoi(input({"1", "2", "3"}));
            switch (bezar) {
                case 1:
                    party.group[i].attack(&zombie);
                    break;
                case 2:
                    if (defender == 4) {
                        defender = i;
                    }
                    party.group[i].defending = true;
                    break;
                case 3:
                    auto usedItem = party.chooseusableitem();

                    if (usedItem->type == "Meds") {
                        party.group[i].useMeds(static_cast<Meds*>(usedItem));
                    } else {
                        zombie.gethit1(static_cast<Throwables*>(usedItem));
                    }
                    break;
            }
        }

        if (zombie.health <= 0) {
            break;
        }

        if (defender != 4) {
        	cout<<"attack zombie";
        	
            zombie.attack(party.group[defender]);
            defender = 4;
       
        } else {
            cout<<"attack zombie";
            zombie.attack(party.group[0]);
        }
   
     party.applyEffects();
     zombie.applyeffects();

        if (zombie.health <= 0) {
            break;
        }

        if (party.lose()) {
            break;
        }
    }}
 vector<Item *> generateRandomLoot(int numWeapons, int numMeds, int numArmor, int numThrowables) {
 vector<Item *> loot;

    vector<string> weaponIDs = {"sword"};
    vector<string> medsIDs = {"health1"};
    vector<string> armorIDs = {"naked1"};
    vector<string> throwablesIDs = {"grenade"};

    srand(time(NULL)); 

    for (int i = 0; i < numWeapons; ++i) {
        string randomWeaponID = weaponIDs[rand() % weaponIDs.size()];
        loot.push_back(new Weapon(randomWeaponID));
    }

    for (int i = 0; i < numMeds; ++i) {
        string randomMedsID = medsIDs[rand() % medsIDs.size()];
        loot.push_back(new Meds(randomMedsID));
    }

    for (int i = 0; i < numArmor; ++i) {
        string randomArmorID = armorIDs[rand() % armorIDs.size()];
        loot.push_back(new Armor(randomArmorID));
    }

    for (int i = 0; i < numThrowables; ++i) {
        string randomThrowablesID = throwablesIDs[rand() % throwablesIDs.size()];
        loot.push_back(new Throwables(randomThrowablesID));
    }

    return loot;
}
